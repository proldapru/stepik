# Конспект по курсу Stepik "Программирование на python" (67)

## Целочисленные операции {#int-operations}
```
5 // 2 # целочисленное деление
5 % 2  # остаток отделения
5 ** 2 # возведение в степень
```

## Операции с вещественными числами {#float-operations}
```
9 ** 0.5 # извлечение квадратного корня
1234e-2  # деление на 10 в степени 2 (экспонента)
1234e2   # умножение на 10 в степени 2 (экспонента)
```

### Преобразования {#type-conversions}
```
int(x)   # к целому числу
float(x) # к вещественному числу
type(x)  # узнать тип объекта

if type(x) is int: print('int') # проверить тип объекта
```

## Запись числа в различных системах счисления
```
x = 0b010101 # Двоичная система
x = 0o765432 # Восьмиричная система
x = 0xF1AB12 # Шестнадцатиричная система
x = int('ZF3', base=36) # Число в произвольной системе счисления, второй именованный аргумент -- основание системы (до 36 включительно)
```

## Представление числа в системах счисления
```
bin(x) # Двоичная система
oct(x) # Восьмиричная система
hex(x) # Шестнадцатиричная система
```

## Чтение пользовательского ввода
input() # ожидание ввода от пользователя
input('Введите значение') # вывод приглашения для ввода
s = input() # ввод дананных в переменную (всегда строка)
s = int(input()) # преобразование ввода пользователя в число

print(a, b) # вывод нескольких объектов (будут разделены пробелом)
print(a, b, c, sep="\n") # вывод нескольких объектов (будут разделены разделителем из параметра sep)
print(a, end='') # в параметре end указывается завершающий символ (по умолчанию это символ перевода строки "\n"). Удобно при выводе табличных данных или в цикле.

sep= и end= -- именованные аргументы функции print()

print('', *range(c, d+1), sep='\t') # Выводится список целых чисел от c до d через табуляцию. В данном случае * означает, что фунции print() передаётся сразу несколько объектов


x1, x2, x3 = True, False, True # присваивание сразу нескольких переменных

a, b = b, a # "Обмен" значениями переменных

Приоритет логических операций:
not > and > or
Приоритет логических операций можно поменять с помощью скобок. Любые арифметические операции выше по приоритету операций сравнения и логических операторов.

Строки
Конкатенация:
'abc' + 'def'
Повтор:
'abc' * 3
Узнать длину:
len('abc')

Генератор range(start=0, stop, step=1) -- stop не входит в диапазон, start входит в диапазон, step может быть отрицательным


if-else в одну строку на примере задачи с окончаниями
n=int(input())
print(n,'программист'+('ов' if n%10==0 or 4<n%10 or 10<n%100<15 else 'а' if 1<n%10<5 else ''))

Чтение целых чисел, вводимых в одной строке через пробел:
a, b = (int(i) for i in input().split())


Обращение к символам строк по их индексам.
genome = 'ATGC'
genome[0] = 'A'		genome[-1] = 'C'
genome[1] = 'T'		genome[-2] = 'G'
genome[2] = 'G'		genome[-3] = 'T'
genome[3] = 'C'		genome[-4] = 'A'

В квадратных скобках может быть два и даже три параметра (это называется slicing). Параметры записываются так Var[A:B:C]. эти параметры, если их больше одного, ведут себя как оператор range(). Первый параметр означает с какого индекса начинать, второй означает на каком индексе закончить (не включая этот индекс) и третий - шаг (по умолчанию 1).

Такое обращение со строкой позволяет выбирать не один а несколько символов или часть строки.
Где А - индекс первого символа. Если его оставить пустым (например, Var[:B]), то перебираться будут все символы с начала строки и до В.
B - (необязательный) индекс последнего символа. Если его оставить пустым (например, Var[A:]), то перебираться будут все символы начиная от A и до конца строки.
С - (необязательный) шаг, через который выбираются символы. По умолчанию, если не указать, равен 1 - т.е перебираются все символы по порядку.

Примеры: var="Hello!"
var[0] -> 'H' - только первый символ
var[1:] -> 'ello!' - все символы начиная со второго
var[:3] -> 'Hell' - все символы до четвертого
var[1:4] -> 'ello' - символы со второго по пятый
var[::] -> 'Hello!' - выведутся все символы
var[::2] -> 'Hlo' - здесь выбирается каджый второй символ строки, т.е. 0й 2й и 4й
var[::-1] -> '!olleH'- выведутся все символы, но с шагом -1 - каждый символ, но в обратном порядке.

Перебор всех символов строки по порядку:
for i in genome: print(i)



Методы объекта str
Посмотреть все доступные методы объекта:
dir(str)

Метод объекта строки .count() подсчитывает количество вхождений одной строки в другую в строку.
print('ATGACC'.count('C'))  # 2

s, p = 'aTGcc', 'cc'
s.upper()	# ATGCC
s.lower()	# atgcc
s.count(p)	# 1 (количество непересекающихся вхождений)
s.find(p)	# 3 (индекс первого вхождения, если вхождений нет, возвращает -1)
# Предпочтительный способ проверки вхождения строки с другую строку:
	if 'TG' in s: print('Found!')
s.replace('c', 'C') # 'aTGCC'

'\t abc \n'.strip() # 'abc'

'a'.isalpha() # True
'a'.isdigit() # False
'We are the champions'.startswith("We") # True

str.maketrans # ???
str.translate # ???


ord('a') # Функция возвращает числовое представление для указанного символа.
ord('a')  # 97
ord('\u2020')  # 8224

Все методы делятся на 2 типа: изменяющие и возвращающие. Все перечисленные выше методы -- возвращающие.



Работа со списками
s = [] # пустой список
s, t = ['a', 'b', 'c'], ['d', 'e']
print(s) # ['a', 'b', 'c'] -- вывод списка как есть
len(s) # длина списка
for i in s: print(i) # проход повсем элементам списка
s + t # ['a', 'b', 'c', 'd', 'e'] -- сложение списков
t * 2 # ['d', 'e', 'd', 'e'] -- умножение списка
К спискам также применяется slicing по аналогии со строками

Изменения списков
s[1] = 'B' # ['a', 'B', 'c'] -- замена конкретного элемента списка
s.append('z') # ['a', 'B', 'c', 'z'] -- добавление в конец
s += ['x'] # вариант добавление через сложение списков
s += ['x', 'y'] # вариант добавление через сложение списков
d.insert(1, 'x') # ['d', 'x', 'e'] -- первый параметр - индекс вставляемого элемента, второй параметр - вставляемый элемент

s = ['a', 'b', 'c']
s += ['Olga'] # ['a', 'b', 'c', 'Olga']
s += 'Olga' # ['a', 'b', 'c', 'Olga', 'O', 'l', 'g', 'a'] -- строка - это список из букв

s = ['a', 'b', 'c', 'c']
s.remove('c') # ['a', 'b', 'c'] -- удаляет первое вхождение элемента
del s[0] # ['b', 'c'] -- удаляет элемент по индексу

s = ['a', 'b', 'c']
if 'a' in s: print('ok') # проверка наличия элемента в списке
if 'e' not in s: print('ok') # проверка отсутсвия элемента в списке
s.index('c') # 2 -- определениеиндекса элемента
s.index('z') # ValueError: 'z' not in list

Сортировка списка
s = ['c', 'b', 'e', 'a']
t = sorted(s) # сортировка без изменения первоначального списка
s.sort() # сортировка с изменением первоначального списка (изменяющий метод)
u = min(s) # 'a'
v = max(s) # 'd'
t = list(reversed(s)) # элементы в обратном порядке без изменения первоначального списка. Сама функция reversed() возвращает объект-итератор, а не список (такой объект можно использоватьв for)
s.reverse() # элементы в обратном порядке с изменением первоначального списка (изменяющий метод)
s[::-1] # элементы в обратном порядке без изменения первоначального списка с помощью slicing

Если s -- список, то после
t = s
оба имени будут ссылаться на один и тот же объект списка. Чтобы t ссылался на копию первоначального списка, можно сделать двумя способами
t = list(s) # создать новый список на основе другого
t = s.copy() # скопировать имеющийся список

Особенности присвоения списков
a = [1, 2, 3]
b = a 			# a = [1, 2, 3]; b = [1, 2, 3]; оба имени указывают на одну и ту же обрасть памяти
a[1] = 4		# a = [1, 4, 3]; b = [1, 4, 3]
b[0] = 5		# a = [5, 5, 3]; b = [5, 4, 3]
a = [6, 7]		# a = [6, 7]; b = [5, 4, 3]; имена указывают на разные области памяти

Генерация спиков
a = [0] * 5
a = [0 for i in range(5)]
a = [i * i for i in range(5)]
a = [i * 3 for i in range(5) if i % 3 == 0] # отбор элементов по условию if
a = [int(i) for i in input().split()]
a = list("12345") # генерация списка из символов строки
a = [int(i) for i in input()]  # генерация списка из символов введённой строки
a = []; a += input() # генерация списка из символов введённой строки

Генерация двухмерного списка n строк на m столбцов, заполненного нулями:
a = [[0 for j in range(m)] for i in range(n)]

Другие функции работы со списками:
s = [1, 1, 2, 3, 3]
s.count(3) # 2
set(s) # [1, 2, 3]



Определение функций
def func0(): ....       # Фунция без параметров
def func1(a, b): ....   # Фунция с двумя параметрами
def func2(*a)^ ....     # Функция с произвольным количеством параметров, a будет списком
def func3(a, b=1): .... # Фунция с двумя параметрами, для параметра b задано значение по умолчанию

При вызове фенкции можно явно использовать имена аргументов, чтобы передать значение именно конкретному аргументу
res = func1(b=2, a=3)

Типы данных бывают изменяемые (mutable) и незменяемые (immutable). При передаче в функцию Mutable тип данных передается по ссылке (list, dict, set), а immutable по значению (int, float, bool, tuple, str, complex).
https://devman.org/qna/26/v-pitone-peremennye-peredajutsja-po-ssylke-ili-po-znacheniju-est-podvodnye-kamni/

List - Элементы в списке хранятся последовательно, каждому из них присвоены индексы, начиная с нуля.
Turple - Кортеж, неизменяемый и более быстрый аналог списка.
Set - Множество, набор уникальных элементов в случайном порядке (неупорядоченный список).

Про типы данных в python https://habr.com/ru/post/319164/

Встроенная функция id(a) позволяет посмотреть идентификатор объекта в памяти (наприемр, проверить, что два имени указывают на один и тот же или разные объекты).


Множества
s = set() # создание пустого множества
s = {'a', 'b', 'c', 'a', 'd', 'b'} # результирующее множество {'c', 'a', 'd', 'b'} (без сохранения порядка элементов)
'a' in s # True
'f' in s # False

Методы и функции множеств
s.add('e')		# добавление, если есть такой элемент, то ничего не происходит
s.remove('f')	# удаление, если элемента в множестве нет, возникнет ошибка
s.discard('f')	# удаление, если элемента в множестве нет, ошибка не возникнет
s.clear()		# очистка (удаление всех элементов)
len(s)			# число элементов в множестве
s1 - s2 		# разность множеств
s1.difference(s2) # тоже разность множеств

Словари
d = dict()	# создание пустого словаря
d = {}		# создание пустого словаря
d = {'a':1, 10:100} # словарь со значениями
'a' in d # True
11 in d  # False
d['b'] = 'val' # Назначение значения ключу
d['b'] # val, получение значения по ключу, если такого ключа нет, возникнет ошибка
d.get('b') # val, получение значения по ключу, если такого ключа нет, ошибка не возникнет (вернётся значение None)
d.get('b', 'default_val') # получение значения по ключу, если такого ключа нет, ошибка не возникнет (вернётся строка default_val)
d.update({'c':333, 'b':222}) # добавление/изменение сразу нескольких пар ключ/значение
del d['b'] # Удаление значения (и ключа) из словаря

d.setdefault(key, []).append(value) # Если ключа нет, он создаётся со значением по умолчанию (в данном случае пустой список, к которому добавлянтся новое значение)

d  = {e:0 for e in l} # создаем словарь на основе списка со значениями 0

dict = {v:k for k, v in dict.items()} # Инверсия словаря

При заполнении словаря было очень удобно использовать функцию zip:
x = ['a','b','c']
y = ['e','f','g']
#будет сгенерирован список в виде [('a', 'e'), ('b', 'f'), ('c', 'g')]
d = {key:value for key, value in zip(x, y)}

Вот быстрый способ создания словаря из двух списков:
s1 - первый список, s2 - второй список
dict(zip (s1,s2))  # ключами при этом будут значения из первого списка

Способы перебора словаря
for key in mydict:
for key in mydict.keys():
for value in mydict.values():
for key, value in mydict.items():
for i, (k, v) in enumerate(mydict.items()):

Чтение из файла

inf = open('file.txt', 'r')  # open('file.txt')
s1 = inf.readline()
s2 = inf.readline()
inf.close()

with open('text.txt') as inf:
    s1 = inf.readline()
    s2 = inf.readline()
# здесь файл уже закрыт


import os
os.path.join('.', 'dirname', 'filename.txt') # '.\\dirname\\filename.txt' (для Windows)

# Построчное чтение из файла
with open('input.txt') as inf:
    for line in inf:
        line = line.strip()
        print(line)


Запись в файл

ouf = open('file.txt', 'w')
ouf.write('Some text\n')	# Перевод строки необходимо указывать явно
ouf.write(str(25))			# Необходимо явно преобразовть число в строку
ouf.close()

with open('text.txt', 'w') as ouf:
    ouf.write('Some text\n')
    ouf.write(str(25))
# здесь файл уже закрыт

# Вариант с print()
output = open('smt.txt', 'w')
print('something', file=output)




Врезка со Степика по list comprehension
===================
# Для тех, кто хочет сократить свой код :) написал небольшое руководство по [list comprehension]
# на основе примера на stackoverflow.com
# # http://stackoverflow.com/questions/16632124/python-emulate-sum-using-list-comprehension
# я немного изменил этот пример, чтобы лучше объяснить работу [list comprehension]
# и вам было проще понять, как применить этот подход к решению задания

# допустим, у нас есть список фруктов, где зафиксированы самые низкие и высокие цены на эти фрукты
# т.е. по сути это список списков :)
lst = [["apple", 55, 62], ["orange", 60, 74], ["pineapple", 140, 180], ["lemon", 80, 84]]

# выведем этот список для нагляности на экран, используя [list comprehension]
[print(el) for el in lst]
# ['apple', 55, 62]
# ['orange', 60, 74]
# ['pineapple', 140, 180]
# ['lemon', 80, 84]

# если мы хотим подсчитать среднюю цену на каждый из фруктов, то напишем что-то вроде
sumMiddle = 0
for el in lst:
    sumMiddle = (el[1] + el[2]) / 2
    print(sumMiddle)

# или можно сделать это одной строкой
[print((priceLow + priceHigh) / 2) for fruit, priceLow, priceHigh in lst]
# представьте, что наш список списков - это таблица из трёх столбцов
# и мы можем обращаться к столбцам, просто озаглавив их fruit, priceLow, priceHigh
# в цикле for, почти как перебор элементов словаря for key, value in d.items() :)

# поэтому, когда вы захотите прикинуть, сколько же, от и до, в среднем может стоить
# ваша фруктовая корзина, нужно будет посчитать среднее по каждой колонке
# вы можете сделать это примерно так
sumLow, sumHigh = 0, 0
for el in lst:
    sumLow += el[1]
    sumHigh += el[2]
sumLow /= len(lst)
sumHigh /= len(lst)
print(sumLow, sumHigh)

# или применить кунг-фу списковых выражений и обойтись парой строк :)
print(sum([priceLow for fruit, priceLow, priceHigh in lst]) / len(lst))
print(sum([priceHigh for fruit, priceLow, priceHigh in lst]) / len(lst))

# а где два принта, там и один :)
print(sum([priceLow for fruit, priceLow, priceHigh in lst]) / len(lst), sum([priceHigh for fruit, priceLow, priceHigh in lst]) / len(lst))

# надеюсь, вам было понятно и интересно
# желаю успехов в учёбе!!!
﻿=====================================



Модули

Варианты импорта модуля:

import my_module
my_module.foo()

from my_module import foo
foo()

from my_module import *
foo()

from my_module import foo as my_foo
my_foo()

print(*__import__("sys").argv[1:]) # Импорт сразу с использованием


Пример с модулем sys:

import sys
print(len(sys.argv))

Пример с модулем subprocess:

import subprocess
subprocess.call(["python", "-h"])

Материалы по модулям:
https://docs.python.org/3/tutorial/modules.html
https://docs.python.org/3/library/
https://www.ibm.com/developerworks/ru/library/l-python_part_5/



Однопроходные алгоритмы
подсчёт (n)					(0)			n += 1
сумма (s)					(0)			s += x
произведение (p)			(1)			p *= x
максимум (m)				(?)			m = max(m, x)
поиск числа в потоке (f)	(False)		f = f or (x==y)
